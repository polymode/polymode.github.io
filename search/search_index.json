{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polymode is an Emacs package that provides support for multiple major modes (MMM) inside a single emacs buffer. It is lightweight, object oriented and highly extensible. Creating new polymodes normally takes a few lines of code. Installation Basic Usage Concepts Defining Polymodes For Developers Screenshots Licence","title":"Home"},{"location":"concepts/","text":"Internally Polymode uses indirect buffers to implement inner spans of different modes. Each inner major mode within a polymode buffer has its own indirect buffer associated with it. Host mode lives in the base buffer. Therefore, switching modes in Polymode is as fast as switching emacs buffers because it never re-installs major modes like most of other MMM frameworks do. Dave Love's multi-mode.el gets full credit for this idea. Terminology span is a contiguous and functionally homogeneous region of text of the same Emacs major mode. On functional grounds, there are 4 types of spans: head, body, tail and host. In the above example there are 5 spans - org host, elisp org header, elisp body, elisp org tail and org host. All spans are closed on the left and open on the right. For example, a span spanning [3, 5) contains character at position 3 but not at position 5. This is consisten with how emacs' functions dealing with text properties work. chunk is a contiguous region that consists of one or more spans . There are two major types of chunks: host chunks which contain only one span - host mode, and inner chunks which commonly consists of head, body and tail, where body is of some other mode than host. polymode , just like an emacs standard mode, means one of the following: an generic term for a collection of related functionality that is available in emacs buffers function which installs a bunch of functionality into emacs buffers. Therefore, you can use polymodes just as any other emacs mode. Configuration Host and inner chunks are configured through objects derived from pm-chunkmode class and are generally referred as \"chunkmodes\". These objects have named of the form pm-host/NAME and pm-inner/NAME and are grouped in hostmodes and innermodes customization groups respectively. During the initialization chunkmodes are cloned and stored in buffer local variable pm/chunkmode. Polymodes are configured through objects of class pm-polymode which are named with pm-poly/NAME scheme where NAME is the root name of the polymode poly-NAME-mode . During initialization of the polymodes the pm-poly/NAME object is cloned and stored in a buffer-local variable pm/polymode which is common across all indirect buffers. It is worth pointing out the difference between chunks and chunkmodes . Chunks are fragments of text and there might be multiple chunks of the same mode within a buffer. In contrast, there is only one chunkmode of some type per buffer and all its chunks \"share\" the chunkmode. At any point of time, each chunkmode is attached to its own buffer (base or indirect) and one emacs major mode. Class Hierarchy Polymode package uses eieio to represent its objects. The root class for all polymode classes is eieio-instance-inheritor which provides prototype based inheritance. This means that objects instantiated from polymode classes can be cloned in order to dynamically create a hierarchy of customizable objects. There are a bunch of such objects already defined, you can check those in polymodes , hostmodes and innermodes customization groups. Current polymode class hierarchy: +--eieio-instance-inheritor +--pm-root +--pm-chunkmode | +--pm-inner-chunkmode | | +--pm-inner-auto-chunkmode | +--pm-host-chunkmode +--pm-polymode +--pm-weaver | +--pm-shell-weaver | +--pm-callback-weaver +--pm-exporter +--pm-shell-exporter +--pm-callback-exporter Using Help with EIEIO: Each eieio class has a corresponding constructor whose docstring contains a complete description of the class. Naming Conventions User facing functionality is named with polymode- prefix. Polymodes are named with poly-ROOT-NAME-mode convention. Classes, methods and development API have pm- prefix. The three fundamental buffer-local objects available in all polymode buffers are pm/polymode , pm/chunkmode and pm/type .","title":"Concepts"},{"location":"concepts/#terminology","text":"span is a contiguous and functionally homogeneous region of text of the same Emacs major mode. On functional grounds, there are 4 types of spans: head, body, tail and host. In the above example there are 5 spans - org host, elisp org header, elisp body, elisp org tail and org host. All spans are closed on the left and open on the right. For example, a span spanning [3, 5) contains character at position 3 but not at position 5. This is consisten with how emacs' functions dealing with text properties work. chunk is a contiguous region that consists of one or more spans . There are two major types of chunks: host chunks which contain only one span - host mode, and inner chunks which commonly consists of head, body and tail, where body is of some other mode than host. polymode , just like an emacs standard mode, means one of the following: an generic term for a collection of related functionality that is available in emacs buffers function which installs a bunch of functionality into emacs buffers. Therefore, you can use polymodes just as any other emacs mode.","title":"Terminology"},{"location":"concepts/#configuration","text":"Host and inner chunks are configured through objects derived from pm-chunkmode class and are generally referred as \"chunkmodes\". These objects have named of the form pm-host/NAME and pm-inner/NAME and are grouped in hostmodes and innermodes customization groups respectively. During the initialization chunkmodes are cloned and stored in buffer local variable pm/chunkmode. Polymodes are configured through objects of class pm-polymode which are named with pm-poly/NAME scheme where NAME is the root name of the polymode poly-NAME-mode . During initialization of the polymodes the pm-poly/NAME object is cloned and stored in a buffer-local variable pm/polymode which is common across all indirect buffers. It is worth pointing out the difference between chunks and chunkmodes . Chunks are fragments of text and there might be multiple chunks of the same mode within a buffer. In contrast, there is only one chunkmode of some type per buffer and all its chunks \"share\" the chunkmode. At any point of time, each chunkmode is attached to its own buffer (base or indirect) and one emacs major mode.","title":"Configuration"},{"location":"concepts/#class-hierarchy","text":"Polymode package uses eieio to represent its objects. The root class for all polymode classes is eieio-instance-inheritor which provides prototype based inheritance. This means that objects instantiated from polymode classes can be cloned in order to dynamically create a hierarchy of customizable objects. There are a bunch of such objects already defined, you can check those in polymodes , hostmodes and innermodes customization groups. Current polymode class hierarchy: +--eieio-instance-inheritor +--pm-root +--pm-chunkmode | +--pm-inner-chunkmode | | +--pm-inner-auto-chunkmode | +--pm-host-chunkmode +--pm-polymode +--pm-weaver | +--pm-shell-weaver | +--pm-callback-weaver +--pm-exporter +--pm-shell-exporter +--pm-callback-exporter Using Help with EIEIO: Each eieio class has a corresponding constructor whose docstring contains a complete description of the class.","title":"Class Hierarchy"},{"location":"concepts/#naming-conventions","text":"User facing functionality is named with polymode- prefix. Polymodes are named with poly-ROOT-NAME-mode convention. Classes, methods and development API have pm- prefix. The three fundamental buffer-local objects available in all polymode buffers are pm/polymode , pm/chunkmode and pm/type .","title":"Naming Conventions"},{"location":"defining-polymodes/","text":"Defining polymodes always starts by defining one host and at least one inner chunkmode. Hosts Modes Here is an example of markdown host mode: (defcustom pm-host/markdown (pm-host-chunkmode \"markdown\" :mode 'markdown-mode) \"Markdown host chunkmode\" :group 'hostmodes :type 'object) Here we call pm-host-chunkmode , the constructor of host chunkmodes, with the :mode parameter which should be the name of a valid emacs major mode function. In this case markdown-mode . Note: First argument in constructors is the name of the object. This name is used in various contexts for object identification . Inner Modes Polymode defines two built-in types of inner chunkmodes, simple pm-inner-chunkmode which allows for one pre-specified mode and pm-inner-auto-chunkmode which detects the type of the chunk dynamically. This is an example of two markdown auto innermodes, one for fenced code and the other for inner code: (defcustom pm-inner/markdown-fenced-code (pm-inner-auto-chunkmode \"markdown-fenced-code\" :head-matcher \"^[ \\t]*```[{ \\t]*\\\\w.*$\" :tail-matcher \"^[ \\t]*```[ \\t]*$\" :mode-matcher (cons \"```[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([^ \\t\\n;=,}]+\\\\)\" 1)) \"Markdown fenced code block.\" :group 'innermodes :type 'object) (defcustom pm-inner/markdown-inline-code (pm-inner-auto-chunkmode \"markdown-inline-code\" :head-matcher (cons \"[^`]\\\\(`{?[[:alpha:]+-]+\\\\)[ \\t]\" 1) :tail-matcher (cons \"[^`]\\\\(`\\\\)[^`]\" 1) :mode-matcher (cons \"`[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([[:alpha:]+-]+\\\\)\" 1) :head-mode 'host :tail-mode 'host) \"Markdown inline code.\" :group 'innermodes :type 'object) Here :head-matcher and :tail-matcher are regular expressions defining the head and the tail of the chunks. The :mode-matcher tells polymode how to retrieve the major mode from the head of the chunk. Each of the three marchers can be a regexp a cons of the form (REGEXP . SUBMATCH) or a function which should return the name of the mode. :head-mode and :tail-mode specify the major mode which should be used for head and tail respectively. If it's a special symbol 'host host mode is used instead, if 'body the chunks body mode. It defaults to poly-head-tail-mode which is at the moment a very basic prog mode with no special powers. Polymodes Finally, use the host and inner modes defined earlier to define the poly-markdown-mode polymode: (define-polymode poly-markdown-mode :hostmode 'pm-host/markdown :innermodes '(pm-inner/markdown-fenced-code pm-inner/markdown-inline-code)) define-polymode is similar to the standard Emacs utilities define-derived-mode and define-minor-mode . It accepts several optional arguments - PARENT polymode to be derived from, DOC string and BODY which is executed in host and every indirect buffer during the installation of the chunkmodes. BODY can be preceded by key-value pairs further refining the configuration. By far the most common keys are :hostmode specify the name of the pm-host-chunkmode object and :innermodes which is a list of names of pm-inner-chunkmode objects. See the documentation of define-polymode for further details. On a technical level polymode functions are more similar to minor-modes. In fact every poly-NAME-mode chunkmode buffer (base or indirect) will have poly-NAME-mode minor mode activated, thus acting like a UI \"glue\" between different chunks. When defining poly-NAME-mode 3 objects are created in the background: poly-NAME-mode function which when can be used as major or minor mode poly-NAME-mode-map keymap which inherits from PARENT 's polymode keymap or polymode-mode-map if no PARENT . pm-poly/NAME configuration object derived (cloned) from the PARENT 's configuration object if PARENT is non-nil. poly-NAME-mode will also run poly-NAME-mode-hook (and all parents' hooks) in every chunkmode buffer after the initialization of the chunkmode has been completed. PARENT argument can also be a configuration object. When creation of polymodes for parent objects has little or no sense. For example pm-poly/latex is as parent of pm-poly/noweb but having a dedicated poly-latex-mode polymode has little sense. (defcustom pm-poly/latex (pm-polymode \"latex\" :hostmode 'pm-host/latex) \"LaTeX typical configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/latex :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) When name of PARENT matches the name of the polymode, define-polymode uses PARENT directly as the configuration object (i.e. no clone or defcustom is performed). Therefore, the above definition of poly-noweb-mode is essentially equivalent to the following: (defcustom pm-poly/noweb (clone pm-poly/latex \"noweb\" :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) \"Noweb polymode configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/noweb)","title":"Defining Polymodes"},{"location":"defining-polymodes/#hosts-modes","text":"Here is an example of markdown host mode: (defcustom pm-host/markdown (pm-host-chunkmode \"markdown\" :mode 'markdown-mode) \"Markdown host chunkmode\" :group 'hostmodes :type 'object) Here we call pm-host-chunkmode , the constructor of host chunkmodes, with the :mode parameter which should be the name of a valid emacs major mode function. In this case markdown-mode . Note: First argument in constructors is the name of the object. This name is used in various contexts for object identification .","title":"Hosts Modes"},{"location":"defining-polymodes/#inner-modes","text":"Polymode defines two built-in types of inner chunkmodes, simple pm-inner-chunkmode which allows for one pre-specified mode and pm-inner-auto-chunkmode which detects the type of the chunk dynamically. This is an example of two markdown auto innermodes, one for fenced code and the other for inner code: (defcustom pm-inner/markdown-fenced-code (pm-inner-auto-chunkmode \"markdown-fenced-code\" :head-matcher \"^[ \\t]*```[{ \\t]*\\\\w.*$\" :tail-matcher \"^[ \\t]*```[ \\t]*$\" :mode-matcher (cons \"```[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([^ \\t\\n;=,}]+\\\\)\" 1)) \"Markdown fenced code block.\" :group 'innermodes :type 'object) (defcustom pm-inner/markdown-inline-code (pm-inner-auto-chunkmode \"markdown-inline-code\" :head-matcher (cons \"[^`]\\\\(`{?[[:alpha:]+-]+\\\\)[ \\t]\" 1) :tail-matcher (cons \"[^`]\\\\(`\\\\)[^`]\" 1) :mode-matcher (cons \"`[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([[:alpha:]+-]+\\\\)\" 1) :head-mode 'host :tail-mode 'host) \"Markdown inline code.\" :group 'innermodes :type 'object) Here :head-matcher and :tail-matcher are regular expressions defining the head and the tail of the chunks. The :mode-matcher tells polymode how to retrieve the major mode from the head of the chunk. Each of the three marchers can be a regexp a cons of the form (REGEXP . SUBMATCH) or a function which should return the name of the mode. :head-mode and :tail-mode specify the major mode which should be used for head and tail respectively. If it's a special symbol 'host host mode is used instead, if 'body the chunks body mode. It defaults to poly-head-tail-mode which is at the moment a very basic prog mode with no special powers.","title":"Inner Modes"},{"location":"defining-polymodes/#polymodes","text":"Finally, use the host and inner modes defined earlier to define the poly-markdown-mode polymode: (define-polymode poly-markdown-mode :hostmode 'pm-host/markdown :innermodes '(pm-inner/markdown-fenced-code pm-inner/markdown-inline-code)) define-polymode is similar to the standard Emacs utilities define-derived-mode and define-minor-mode . It accepts several optional arguments - PARENT polymode to be derived from, DOC string and BODY which is executed in host and every indirect buffer during the installation of the chunkmodes. BODY can be preceded by key-value pairs further refining the configuration. By far the most common keys are :hostmode specify the name of the pm-host-chunkmode object and :innermodes which is a list of names of pm-inner-chunkmode objects. See the documentation of define-polymode for further details. On a technical level polymode functions are more similar to minor-modes. In fact every poly-NAME-mode chunkmode buffer (base or indirect) will have poly-NAME-mode minor mode activated, thus acting like a UI \"glue\" between different chunks. When defining poly-NAME-mode 3 objects are created in the background: poly-NAME-mode function which when can be used as major or minor mode poly-NAME-mode-map keymap which inherits from PARENT 's polymode keymap or polymode-mode-map if no PARENT . pm-poly/NAME configuration object derived (cloned) from the PARENT 's configuration object if PARENT is non-nil. poly-NAME-mode will also run poly-NAME-mode-hook (and all parents' hooks) in every chunkmode buffer after the initialization of the chunkmode has been completed. PARENT argument can also be a configuration object. When creation of polymodes for parent objects has little or no sense. For example pm-poly/latex is as parent of pm-poly/noweb but having a dedicated poly-latex-mode polymode has little sense. (defcustom pm-poly/latex (pm-polymode \"latex\" :hostmode 'pm-host/latex) \"LaTeX typical configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/latex :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) When name of PARENT matches the name of the polymode, define-polymode uses PARENT directly as the configuration object (i.e. no clone or defcustom is performed). Therefore, the above definition of poly-noweb-mode is essentially equivalent to the following: (defcustom pm-poly/noweb (clone pm-poly/latex \"noweb\" :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) \"Noweb polymode configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/noweb)","title":"Polymodes"},{"location":"installation/","text":"Note: Polymode supports Emacs version is 25.1 or higher Via package.el Polymode is available on the two major package.el community maintained repos - MELPA Stable and MELPA . You can install Polymode, or more commonly a specific polymode, interactively M-x package-install [RET] polymode [RET] M-x package-install [RET] poly-markdown [RET] ... In order to see all available polymodes do M-x list-packages [RET] and search for poly- prefix. To automatically install relevant polymodes put the following lines into .emacs for each polymode that you use: (unless (package-installed-p 'polymode) (package-install 'poly-markdown)) You can pin packages to always install from MELPA stable like follows: (add-to-list 'package-pinned-packages '(poly-markdown . \"melpa-stable\") t) Via use-package use-package can also be used to install Polymode via the package.el . (use-package poly-markdown :ensure t) Or from MELPA stable: (use-package poly-markdown :ensure t :pin melpa-stable) For further configuration options with use-package see the official use-package repository or C-h v use-package [RET] . Manually cd path/to/vc/dir git clone https://github.com/emacs-polymode/polymode git clone https://github.com/emacs-polymode/poly-markdown ... In .emacs add \"polymode\" directory and \"polymode/modes\" to the load path: (setq load-path (append '(\"path/to/vc/dir/polymode/\" \"path/to/vc/dir/poly-markdown/\") load-path)) Require any polymode bundles that you are interested in. For example: (require 'poly-markdown) Activation of Polymodes Polymodes are functions and can be used just like ordinary emacs modes. Particularly, activate them in files by either registering a file extension in auto-mode-alist (add-to-list 'auto-mode-alist '(\"\\\\.mymd\" . poly-markdown-mode)) or by setting local major mode variable in the header of the file: // -*- mode: poly-noweb -*- Normally you won't need to setup modes yourself as polymode packages register their polymodes with the common extensions automatically. See the documentation of each polymode package.","title":"Installation"},{"location":"installation/#via-packageel","text":"Polymode is available on the two major package.el community maintained repos - MELPA Stable and MELPA . You can install Polymode, or more commonly a specific polymode, interactively M-x package-install [RET] polymode [RET] M-x package-install [RET] poly-markdown [RET] ... In order to see all available polymodes do M-x list-packages [RET] and search for poly- prefix. To automatically install relevant polymodes put the following lines into .emacs for each polymode that you use: (unless (package-installed-p 'polymode) (package-install 'poly-markdown)) You can pin packages to always install from MELPA stable like follows: (add-to-list 'package-pinned-packages '(poly-markdown . \"melpa-stable\") t)","title":"Via package.el"},{"location":"installation/#via-use-package","text":"use-package can also be used to install Polymode via the package.el . (use-package poly-markdown :ensure t) Or from MELPA stable: (use-package poly-markdown :ensure t :pin melpa-stable) For further configuration options with use-package see the official use-package repository or C-h v use-package [RET] .","title":"Via use-package"},{"location":"installation/#manually","text":"cd path/to/vc/dir git clone https://github.com/emacs-polymode/polymode git clone https://github.com/emacs-polymode/poly-markdown ... In .emacs add \"polymode\" directory and \"polymode/modes\" to the load path: (setq load-path (append '(\"path/to/vc/dir/polymode/\" \"path/to/vc/dir/poly-markdown/\") load-path)) Require any polymode bundles that you are interested in. For example: (require 'poly-markdown)","title":"Manually"},{"location":"installation/#activation-of-polymodes","text":"Polymodes are functions and can be used just like ordinary emacs modes. Particularly, activate them in files by either registering a file extension in auto-mode-alist (add-to-list 'auto-mode-alist '(\"\\\\.mymd\" . poly-markdown-mode)) or by setting local major mode variable in the header of the file: // -*- mode: poly-noweb -*- Normally you won't need to setup modes yourself as polymode packages register their polymodes with the common extensions automatically. See the documentation of each polymode package.","title":"Activation of Polymodes"},{"location":"internals/","text":"API All API classes and methods are named with pm- prefix. Buffer local objects: pm/type pm/chunkmode pm/polymode Generics: pm-initialize pm-get-buffer-create pm-select-buffer pm-get-span pm-indent-line pm-get-adjust-face Utilities: Spans: pm-innermost-span pm-map-over-spans pm-narrow-to-span Buffers pm-set-buffer pm-switch-to-buffer Others pm-fun-matcher Initialization of polymodes TODO Poly Lock TODO Debugging Polymodes You can visually inspect if the polymode does what you intended by activating globalized pm-debug minor mode with M-x pm-debug-mode . When pm-debug-mode is active the current span will be highlighted. Some useful commands defined in pm-debug-mode-map : Shortcut Description M-n M-f Toggle font-locking ( pm-debug-toggle-fontification ) M-n M-h Map through all spans and briefly blink each span ( pm-debug-map-over-spans-and-highlight ) M-n M-i Highlight current span and display more info ( pm-debug-info-on-span ) M-n M-p Print values of relevant variables in current buffer ( pm-debug-print-relevant-variables ) M-n M-t i Toggle info messages ( pm-debug-toogle-info-message ) M-n M-t f Toggle whether font-lock should be performed ( pm-debug-toggle-fontification ) M-n M-t p Toggle post-command hook ( pm-debug-toggle-post-command ) M-n M-t c Toggle after-change hook ( pm-debug-toggle-after-change ) M-n M-t a Toggle all ( pm-debug-toggle-all ) M-n M-t v Toggle verbose messages from polymode ( pm-debug-toggle-verbose ) M-n M-f s Fontify current span (useful for font-lock debugging when font-lock is off) ( pm-debug-fontify-current-span ) M-n M-f b Fontify current buffer ( pm-debug-fontify-current-buffer )","title":"For Developers"},{"location":"internals/#api","text":"All API classes and methods are named with pm- prefix. Buffer local objects: pm/type pm/chunkmode pm/polymode Generics: pm-initialize pm-get-buffer-create pm-select-buffer pm-get-span pm-indent-line pm-get-adjust-face Utilities: Spans: pm-innermost-span pm-map-over-spans pm-narrow-to-span Buffers pm-set-buffer pm-switch-to-buffer Others pm-fun-matcher","title":"API"},{"location":"internals/#initialization-of-polymodes","text":"TODO","title":"Initialization of polymodes"},{"location":"internals/#poly-lock","text":"TODO","title":"Poly Lock"},{"location":"internals/#debugging-polymodes","text":"You can visually inspect if the polymode does what you intended by activating globalized pm-debug minor mode with M-x pm-debug-mode . When pm-debug-mode is active the current span will be highlighted. Some useful commands defined in pm-debug-mode-map : Shortcut Description M-n M-f Toggle font-locking ( pm-debug-toggle-fontification ) M-n M-h Map through all spans and briefly blink each span ( pm-debug-map-over-spans-and-highlight ) M-n M-i Highlight current span and display more info ( pm-debug-info-on-span ) M-n M-p Print values of relevant variables in current buffer ( pm-debug-print-relevant-variables ) M-n M-t i Toggle info messages ( pm-debug-toogle-info-message ) M-n M-t f Toggle whether font-lock should be performed ( pm-debug-toggle-fontification ) M-n M-t p Toggle post-command hook ( pm-debug-toggle-post-command ) M-n M-t c Toggle after-change hook ( pm-debug-toggle-after-change ) M-n M-t a Toggle all ( pm-debug-toggle-all ) M-n M-t v Toggle verbose messages from polymode ( pm-debug-toggle-verbose ) M-n M-f s Fontify current span (useful for font-lock debugging when font-lock is off) ( pm-debug-fontify-current-span ) M-n M-f b Fontify current buffer ( pm-debug-fontify-current-buffer )","title":"Debugging Polymodes"},{"location":"licence/","text":"Copyright (C) 2012-2016 Vitalie Spinu and contributors . Polymode is distributed under the GNU General Public License, version 3, the same as Emacs. Type C-h C-c in Emacs to view it.","title":"Licence"},{"location":"screenshots/","text":"Screenshots Slim Markdown+R Markdown+R+YAML Org mode Ess-help buffer C++R","title":"Screenshots"},{"location":"screenshots/#screenshots","text":"","title":"Screenshots"},{"location":"screenshots/#slim","text":"","title":"Slim"},{"location":"screenshots/#markdownr","text":"","title":"Markdown+R"},{"location":"screenshots/#markdownryaml","text":"","title":"Markdown+R+YAML"},{"location":"screenshots/#org-mode","text":"","title":"Org mode"},{"location":"screenshots/#ess-help-buffer","text":"","title":"Ess-help buffer"},{"location":"screenshots/#cr","text":"","title":"C++R"},{"location":"usage/","text":"All polymode keys start with the prefix defined by polymode-prefix-key (defaults to M-n ). The polymode-mode-map is the parent of all polymodes' maps. Navigation Shortcut Description C-n Move to next chunk ( polymode-next-chunk ) C-p Move to previous chunk ( polymode-previous-chunk ) C-M-n Move to next chunk of the same type ( polymode-next-chunk-same-type ) C-M-p Move to previous chunk of the same type ( polymode-previous-chunk-same-type ) Chunk Manipulation Shortcut Description M-k Kill current chunk ( polymode-kill-chunk ) C-t Toggle narrowing of the body of current chunk ( polymode-toggle-chunk-narrowing ) M-m ;; not implemented ( polymode-mark-or-extend-chunk ) M-i ;; not implemented yet ( polymode-insert-new-chunk ) Exporting, Weaving and Tangling Shortcut Description e Export the document with the current exporter. ( polymode-export ) E Ask and set the current exporter. ( polymode-set-exporter ) w Weave the document with the current weaver. ( polymode-weave ) W Ask and set the current weaver. ( polymode-set-weaver ) t ;; not implemented yet ( polymode-tangle ) T ;; not implemented yet ( polymode-set-tangler ) $ Show the process buffer is something went wrong during the processing. ( polymode-show-process-buffer )","title":"Basic Usage"},{"location":"usage/#navigation","text":"Shortcut Description C-n Move to next chunk ( polymode-next-chunk ) C-p Move to previous chunk ( polymode-previous-chunk ) C-M-n Move to next chunk of the same type ( polymode-next-chunk-same-type ) C-M-p Move to previous chunk of the same type ( polymode-previous-chunk-same-type )","title":"Navigation"},{"location":"usage/#chunk-manipulation","text":"Shortcut Description M-k Kill current chunk ( polymode-kill-chunk ) C-t Toggle narrowing of the body of current chunk ( polymode-toggle-chunk-narrowing ) M-m ;; not implemented ( polymode-mark-or-extend-chunk ) M-i ;; not implemented yet ( polymode-insert-new-chunk )","title":"Chunk Manipulation"},{"location":"usage/#exporting-weaving-and-tangling","text":"Shortcut Description e Export the document with the current exporter. ( polymode-export ) E Ask and set the current exporter. ( polymode-set-exporter ) w Weave the document with the current weaver. ( polymode-weave ) W Ask and set the current weaver. ( polymode-set-weaver ) t ;; not implemented yet ( polymode-tangle ) T ;; not implemented yet ( polymode-set-tangler ) $ Show the process buffer is something went wrong during the processing. ( polymode-show-process-buffer )","title":"Exporting, Weaving and Tangling"}]}