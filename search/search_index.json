{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polymode is a framework for multiple major modes (MMM) inside a single Emacs buffer. It is fast and has a simple but flexible object oriented design. Creating new polymodes normally takes a few lines of code. Installation Basic Usage Concepts Defining Polymodes For Developers Screenshots Licence","title":"Home"},{"location":"concepts/","text":"Internally Polymode uses indirect buffers to implement inner spans of different modes. Each inner major mode within a polymode buffer has its own indirect buffer associated with it. Host mode lives in the base buffer. Therefore, switching modes in Polymode is as fast as switching emacs buffers because it never re-installs major modes like most of other MMM frameworks do. Dave Love's multi-mode.el gets full credit for this idea. By sibling buffers we mean base or indirect buffers which are shared with the current buffer. Terminology span is a contiguous and functionally homogeneous region of text of the same Emacs major mode. On functional grounds, there are 4 types of spans: head, body, tail and host. In the above example there are 5 spans - org host, elisp org header, elisp body, elisp org tail and org host. All spans are closed on the left and open on the right. For example, a span spanning [3, 5) contains character at position 3 but not at position 5. This is consisten with how emacs' functions dealing with text properties work. chunk is a contiguous region that consists of one or more spans . There are two major types of chunks: host chunks which contain only one span - host mode, and inner chunks which commonly consists of head, body and tail, where body is of some other mode than host. polymode , just like an emacs standard mode, means one of the following: an generic term for a collection of related functionality that is available in emacs buffers function which installs a bunch of functionality into emacs buffers. Therefore, you can use polymodes just as any other emacs mode. Configuration Host and inner chunks are configured through objects derived from pm-chunkmode class and are generically referred to as \"chunkmodes\". These objects have named of the form pm-host/NAME and pm-inner/NAME and are collectively called hostmodes and innermodes respectively. These objects are configurable through the custom interface in poly-hostmodes and poly-innermodes customization groups. Polymodes are configured through objects of class pm-polymode which are named with pm-poly/NAME scheme where NAME is the same as in the polymode function poly-NAME-mode . During initialization of the polymodes the pm-poly/NAME object is cloned and stored in a buffer-local variable pm/polymode . This object is shared common across all sibling buffers. It is worth pointing out the difference between chunks and chunkmodes . Chunks are fragments of text and there might be multiple chunks of the same mode within a buffer. In contrast, there is only one chunkmode of some type per buffer and all its chunks \"share\" this chunkmode. Class Hierarchy Polymode package uses eieio to represent its objects. The root class for all polymode classes is eieio-instance-inheritor which provides prototype based inheritance. This means that objects instantiated from polymode classes can be cloned in order to dynamically create a hierarchy of customizable objects. There are a bunch of such objects already defined, you can check those in polymodes , poly-hostmodes and poly-innermodes customization groups. Polymode class hierarchy: +--eieio-instance-inheritor +--pm-root +--pm-polymode +--pm-chunkmode | +--pm-inner-chunkmode | | +--pm-inner-auto-chunkmode | +--pm-host-chunkmode +--pm-weaver | +--pm-shell-weaver | +--pm-callback-weaver +--pm-exporter +--pm-shell-exporter +--pm-callback-exporter Using Help with EIEIO: Each eieio class has a corresponding constructor whose docstring contains a complete description of the class. Naming Conventions User facing functionality is named with polymode- prefix. Polymodes are named with poly-NAME-mode convention. Host, inner and polymode configuration objects start with pm-host/ , pm-inner/ and pm-poly/ prefixes respectively. Classes, methods and development API have pm- prefix.","title":"Concepts"},{"location":"concepts/#terminology","text":"span is a contiguous and functionally homogeneous region of text of the same Emacs major mode. On functional grounds, there are 4 types of spans: head, body, tail and host. In the above example there are 5 spans - org host, elisp org header, elisp body, elisp org tail and org host. All spans are closed on the left and open on the right. For example, a span spanning [3, 5) contains character at position 3 but not at position 5. This is consisten with how emacs' functions dealing with text properties work. chunk is a contiguous region that consists of one or more spans . There are two major types of chunks: host chunks which contain only one span - host mode, and inner chunks which commonly consists of head, body and tail, where body is of some other mode than host. polymode , just like an emacs standard mode, means one of the following: an generic term for a collection of related functionality that is available in emacs buffers function which installs a bunch of functionality into emacs buffers. Therefore, you can use polymodes just as any other emacs mode.","title":"Terminology"},{"location":"concepts/#configuration","text":"Host and inner chunks are configured through objects derived from pm-chunkmode class and are generically referred to as \"chunkmodes\". These objects have named of the form pm-host/NAME and pm-inner/NAME and are collectively called hostmodes and innermodes respectively. These objects are configurable through the custom interface in poly-hostmodes and poly-innermodes customization groups. Polymodes are configured through objects of class pm-polymode which are named with pm-poly/NAME scheme where NAME is the same as in the polymode function poly-NAME-mode . During initialization of the polymodes the pm-poly/NAME object is cloned and stored in a buffer-local variable pm/polymode . This object is shared common across all sibling buffers. It is worth pointing out the difference between chunks and chunkmodes . Chunks are fragments of text and there might be multiple chunks of the same mode within a buffer. In contrast, there is only one chunkmode of some type per buffer and all its chunks \"share\" this chunkmode.","title":"Configuration"},{"location":"concepts/#class-hierarchy","text":"Polymode package uses eieio to represent its objects. The root class for all polymode classes is eieio-instance-inheritor which provides prototype based inheritance. This means that objects instantiated from polymode classes can be cloned in order to dynamically create a hierarchy of customizable objects. There are a bunch of such objects already defined, you can check those in polymodes , poly-hostmodes and poly-innermodes customization groups. Polymode class hierarchy: +--eieio-instance-inheritor +--pm-root +--pm-polymode +--pm-chunkmode | +--pm-inner-chunkmode | | +--pm-inner-auto-chunkmode | +--pm-host-chunkmode +--pm-weaver | +--pm-shell-weaver | +--pm-callback-weaver +--pm-exporter +--pm-shell-exporter +--pm-callback-exporter Using Help with EIEIO: Each eieio class has a corresponding constructor whose docstring contains a complete description of the class.","title":"Class Hierarchy"},{"location":"concepts/#naming-conventions","text":"User facing functionality is named with polymode- prefix. Polymodes are named with poly-NAME-mode convention. Host, inner and polymode configuration objects start with pm-host/ , pm-inner/ and pm-poly/ prefixes respectively. Classes, methods and development API have pm- prefix.","title":"Naming Conventions"},{"location":"defining-polymodes/","text":"Defining polymodes always starts with defining one host chunkmode and at least one inner chunkmode. Hosts Modes Here is an example of markdown host mode: (defcustom pm-host/markdown (pm-host-chunkmode :name \"markdown\" :mode 'markdown-mode) \"Markdown host chunkmode\" :group 'poly-hostmodes :type 'object) Here we call the constructor of host chunkmode objects pm-host-chunkmode with the :mode parameter which should be a name (symbol) of a valid emacs major mode function. In this case markdown-mode . The :name slot is used in various contexts for object identification and information messages. A wide range of hostmodes is already defined in the polymode-base.el file. Consider re-using or clonning those for your own polymodes. Inner Modes Polymode defines two built-in types of inner chunkmodes - pm-inner-chunkmode which allows for one pre-specified mode and pm-inner-auto-chunkmode which detects the type of the body span dynamically. This is an example of two markdown auto innermodes: (defcustom pm-inner/markdown-fenced-code (pm-inner-auto-chunkmode :name \"markdown-fenced-code\" :head-matcher \"^[ \\t]*```[{ \\t]*\\\\w.*$\" :tail-matcher \"^[ \\t]*```[ \\t]*$\" :mode-matcher (cons \"```[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([^ \\t\\n;=,}]+\\\\)\" 1)) \"Markdown fenced code block.\" :group 'poly-innermodes :type 'object) (defcustom pm-inner/markdown-inline-code (pm-inner-auto-chunkmode :name \"markdown-inline-code\" :head-matcher (cons \"[^`]\\\\(`{?[[:alpha:]+-]+\\\\)[ \\t]\" 1) :tail-matcher (cons \"[^`]\\\\(`\\\\)[^`]\" 1) :mode-matcher (cons \"`[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([[:alpha:]+-]+\\\\)\" 1) :head-mode 'host :tail-mode 'host) \"Markdown inline code.\" :group 'poly-innermodes :type 'object) Here :head-matcher and :tail-matcher are regular expressions used to search for heads and tails of inner code chunks. The :mode-matcher tells polymode how to retrieve the major mode from the head of the chunk. Each of the three marchers can be a regexp a cons of the form (REGEXP . SUBMATCH) or a function which should return the name of the mode. :head-mode and :tail-mode specify the major mode which should be used for head and tail respectively. Special symbol 'host means that the host mode is used for head or tail; if 'body the chunk's body mode. Head and tail modes default to poly-head-tail-mode which is a very basic prog mode with no special powers. Polymodes Finally, use the host and inner modes defined earlier to define the poly-markdown-mode polymode: (define-polymode poly-markdown-mode :hostmode 'pm-host/markdown :innermodes '(pm-inner/markdown-fenced-code pm-inner/markdown-inline-code)) define-polymode is similar to the standard Emacs utilities define-derived-mode and define-minor-mode . It accepts several optional arguments - PARENT polymode to be derived from, DOC string and BODY which is executed in host and every indirect buffer during the installation of the chunkmodes. BODY can be preceded by key-value pairs further refining the configuration. By far the most common keys are :hostmode specify the name of the pm-host-chunkmode object and :innermodes which is a list of names of pm-inner-chunkmode objects. See the documentation of define-polymode for further details. At the implementation level polymode functions are more similar to minor-modes than major modes. In fact every poly-NAME-mode chunkmode buffer (base or indirect) will have poly-NAME-mode minor mode activated in order to provide the \"glue\" interface between different chunks. If you want some commands to be available in all chunks bind them in poly-NAME-mode-map or directly in poly-mode-map which is the root map of all polymode maps. A call to define-polymode creates 3 objects in the background: poly-NAME-mode function which when can be used as major or minor mode poly-NAME-mode-map keymap which inherits from PARENT 's polymode keymap or polymode-mode-map if no PARENT has been provided pm-poly/NAME configuration object derived (cloned) from pm-polymode object or the PARENT 's configuration object if PARENT has been provided poly-NAME-mode will also run poly-NAME-mode-hook (and all parents' hooks) in every chunkmode buffer after the initialization of the chunkmode has been completed. Config Objects as Parents PARENT argument can also be a configuration object. Occasionally the creation of polymodes for parent objects has little or no sense. For example pm-poly/latex is as parent of pm-poly/noweb but having a dedicated poly-latex-mode polymode has no sense. (defcustom pm-poly/latex (pm-polymode :name \"latex\" :hostmode 'pm-host/latex) \"LaTeX typical configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/latex :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) In a special case when name of PARENT matches the name of the polymode, PARENT is used directly as the configuration object (no clone or defcustom is performed; it wouldn't make sense). Therefore, the above definition of poly-noweb-mode is equivalent to the following definition with an explicit pm-poly/noweb config: (defcustom pm-poly/noweb (clone pm-poly/latex \"noweb\" :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) \"Noweb polymode configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/noweb)","title":"Defining Polymodes"},{"location":"defining-polymodes/#hosts-modes","text":"Here is an example of markdown host mode: (defcustom pm-host/markdown (pm-host-chunkmode :name \"markdown\" :mode 'markdown-mode) \"Markdown host chunkmode\" :group 'poly-hostmodes :type 'object) Here we call the constructor of host chunkmode objects pm-host-chunkmode with the :mode parameter which should be a name (symbol) of a valid emacs major mode function. In this case markdown-mode . The :name slot is used in various contexts for object identification and information messages. A wide range of hostmodes is already defined in the polymode-base.el file. Consider re-using or clonning those for your own polymodes.","title":"Hosts Modes"},{"location":"defining-polymodes/#inner-modes","text":"Polymode defines two built-in types of inner chunkmodes - pm-inner-chunkmode which allows for one pre-specified mode and pm-inner-auto-chunkmode which detects the type of the body span dynamically. This is an example of two markdown auto innermodes: (defcustom pm-inner/markdown-fenced-code (pm-inner-auto-chunkmode :name \"markdown-fenced-code\" :head-matcher \"^[ \\t]*```[{ \\t]*\\\\w.*$\" :tail-matcher \"^[ \\t]*```[ \\t]*$\" :mode-matcher (cons \"```[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([^ \\t\\n;=,}]+\\\\)\" 1)) \"Markdown fenced code block.\" :group 'poly-innermodes :type 'object) (defcustom pm-inner/markdown-inline-code (pm-inner-auto-chunkmode :name \"markdown-inline-code\" :head-matcher (cons \"[^`]\\\\(`{?[[:alpha:]+-]+\\\\)[ \\t]\" 1) :tail-matcher (cons \"[^`]\\\\(`\\\\)[^`]\" 1) :mode-matcher (cons \"`[ \\t]*{?\\\\(?:lang *= *\\\\)?\\\\([[:alpha:]+-]+\\\\)\" 1) :head-mode 'host :tail-mode 'host) \"Markdown inline code.\" :group 'poly-innermodes :type 'object) Here :head-matcher and :tail-matcher are regular expressions used to search for heads and tails of inner code chunks. The :mode-matcher tells polymode how to retrieve the major mode from the head of the chunk. Each of the three marchers can be a regexp a cons of the form (REGEXP . SUBMATCH) or a function which should return the name of the mode. :head-mode and :tail-mode specify the major mode which should be used for head and tail respectively. Special symbol 'host means that the host mode is used for head or tail; if 'body the chunk's body mode. Head and tail modes default to poly-head-tail-mode which is a very basic prog mode with no special powers.","title":"Inner Modes"},{"location":"defining-polymodes/#polymodes","text":"Finally, use the host and inner modes defined earlier to define the poly-markdown-mode polymode: (define-polymode poly-markdown-mode :hostmode 'pm-host/markdown :innermodes '(pm-inner/markdown-fenced-code pm-inner/markdown-inline-code)) define-polymode is similar to the standard Emacs utilities define-derived-mode and define-minor-mode . It accepts several optional arguments - PARENT polymode to be derived from, DOC string and BODY which is executed in host and every indirect buffer during the installation of the chunkmodes. BODY can be preceded by key-value pairs further refining the configuration. By far the most common keys are :hostmode specify the name of the pm-host-chunkmode object and :innermodes which is a list of names of pm-inner-chunkmode objects. See the documentation of define-polymode for further details. At the implementation level polymode functions are more similar to minor-modes than major modes. In fact every poly-NAME-mode chunkmode buffer (base or indirect) will have poly-NAME-mode minor mode activated in order to provide the \"glue\" interface between different chunks. If you want some commands to be available in all chunks bind them in poly-NAME-mode-map or directly in poly-mode-map which is the root map of all polymode maps. A call to define-polymode creates 3 objects in the background: poly-NAME-mode function which when can be used as major or minor mode poly-NAME-mode-map keymap which inherits from PARENT 's polymode keymap or polymode-mode-map if no PARENT has been provided pm-poly/NAME configuration object derived (cloned) from pm-polymode object or the PARENT 's configuration object if PARENT has been provided poly-NAME-mode will also run poly-NAME-mode-hook (and all parents' hooks) in every chunkmode buffer after the initialization of the chunkmode has been completed.","title":"Polymodes"},{"location":"defining-polymodes/#config-objects-as-parents","text":"PARENT argument can also be a configuration object. Occasionally the creation of polymodes for parent objects has little or no sense. For example pm-poly/latex is as parent of pm-poly/noweb but having a dedicated poly-latex-mode polymode has no sense. (defcustom pm-poly/latex (pm-polymode :name \"latex\" :hostmode 'pm-host/latex) \"LaTeX typical configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/latex :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) In a special case when name of PARENT matches the name of the polymode, PARENT is used directly as the configuration object (no clone or defcustom is performed; it wouldn't make sense). Therefore, the above definition of poly-noweb-mode is equivalent to the following definition with an explicit pm-poly/noweb config: (defcustom pm-poly/noweb (clone pm-poly/latex \"noweb\" :innermodes '(pm-inner/noweb) :keylist '((\"<\" . poly-noweb-electric-<))) \"Noweb polymode configuration.\" :group 'polymodes :type 'object) (define-polymode poly-noweb-mode pm-poly/noweb)","title":"Config Objects as Parents"},{"location":"installation/","text":"!! Polymode required Emacs version 25.1 or higher!! Via package.el Polymode is available on the two major package.el community maintained repos - MELPA Stable and MELPA . You can install Polymode, or more commonly a specific polymode, interactively M-x package-install [RET] polymode [RET] M-x package-install [RET] poly-markdown [RET] ... In order to see all available polymodes do M-x list-packages [RET] and search for poly- prefix. To automatically install relevant polymodes put the following lines into .emacs for each polymode that you use: (unless (package-installed-p 'polymode) (package-install 'poly-markdown)) You can pin packages to always install from MELPA stable like follows: (add-to-list 'package-pinned-packages '(poly-markdown . \"melpa-stable\") t) Via use-package use-package can also be used to install Polymode via the package.el . (use-package poly-markdown :ensure t) Or from MELPA stable: (use-package poly-markdown :ensure t :pin melpa-stable) For further configuration options with use-package see the official use-package repository or C-h v use-package [RET] . Manually cd path/to/vc/dir git clone https://github.com/polymode/polymode git clone https://github.com/polymode/poly-markdown ... In .emacs add \"polymode\" directory and \"polymode/modes\" to the load path: (setq load-path (append '(\"path/to/vc/dir/polymode/\" \"path/to/vc/dir/poly-markdown/\") load-path)) Require any polymode bundles that you are interested in. For example: (require 'poly-markdown) Activation of Polymodes Polymodes are functions and can be used just like ordinary emacs modes. Particularly, activate them in files by either registering a file extension in auto-mode-alist (add-to-list 'auto-mode-alist '(\"\\\\.md\" . poly-markdown-mode)) or by setting local major mode variable in the header of the file: // -*- mode: poly-noweb -*- Normally you won't need to setup modes yourself as polymode packages register their polymodes with the common extensions automatically. See the documentation of each polymode package.","title":"Installation"},{"location":"installation/#via-packageel","text":"Polymode is available on the two major package.el community maintained repos - MELPA Stable and MELPA . You can install Polymode, or more commonly a specific polymode, interactively M-x package-install [RET] polymode [RET] M-x package-install [RET] poly-markdown [RET] ... In order to see all available polymodes do M-x list-packages [RET] and search for poly- prefix. To automatically install relevant polymodes put the following lines into .emacs for each polymode that you use: (unless (package-installed-p 'polymode) (package-install 'poly-markdown)) You can pin packages to always install from MELPA stable like follows: (add-to-list 'package-pinned-packages '(poly-markdown . \"melpa-stable\") t)","title":"Via package.el"},{"location":"installation/#via-use-package","text":"use-package can also be used to install Polymode via the package.el . (use-package poly-markdown :ensure t) Or from MELPA stable: (use-package poly-markdown :ensure t :pin melpa-stable) For further configuration options with use-package see the official use-package repository or C-h v use-package [RET] .","title":"Via use-package"},{"location":"installation/#manually","text":"cd path/to/vc/dir git clone https://github.com/polymode/polymode git clone https://github.com/polymode/poly-markdown ... In .emacs add \"polymode\" directory and \"polymode/modes\" to the load path: (setq load-path (append '(\"path/to/vc/dir/polymode/\" \"path/to/vc/dir/poly-markdown/\") load-path)) Require any polymode bundles that you are interested in. For example: (require 'poly-markdown)","title":"Manually"},{"location":"installation/#activation-of-polymodes","text":"Polymodes are functions and can be used just like ordinary emacs modes. Particularly, activate them in files by either registering a file extension in auto-mode-alist (add-to-list 'auto-mode-alist '(\"\\\\.md\" . poly-markdown-mode)) or by setting local major mode variable in the header of the file: // -*- mode: poly-noweb -*- Normally you won't need to setup modes yourself as polymode packages register their polymodes with the common extensions automatically. See the documentation of each polymode package.","title":"Activation of Polymodes"},{"location":"internals/","text":"Major Modes Guidelines In order for major modes to work well with polimodes major modes should abide the following rules: Don't assume that there is no narrowing in place. If you retrieve text-properties or access a point in a buffer, make sure it's inside the accessible region of the buffer. Pay special attention to what happens at point-max . Use syntax-ppss instead of parse-partial-sexp . If your mode uses or defines some notion of a span or chunk, follow Emacs convention for text properties and consider spans as [left closed and right open) intervals. API All API classes and methods are named with pm- prefix. Buffer local objects: pm/polymode pm/chunkmode [!! don't rely on this one. Likely to change !!] Generics: pm-initialize pm-get-buffer-create pm-select-buffer pm-get-span pm-indent-line pm-get-adjust-face Utilities: Spans: pm-innermost-span pm-map-over-spans pm-narrow-to-span Buffers pm-set-buffer pm-switch-to-buffer Others pm-fun-matcher Initialization of polymodes TODO Poly Lock TODO Debugging Polymodes You can visually inspect if the polymode does what you intended by activating globalized pm-debug minor mode with M-x pm-debug-mode . When pm-debug-mode is active the current span will be highlighted. Some useful commands defined in pm-debug-mode-map : Shortcut Description M-n M-f Toggle font-locking ( pm-debug-toggle-fontification ) M-n M-h Map through all spans and briefly blink each span ( pm-debug-map-over-spans-and-highlight ) M-n M-i Highlight current span and display more info ( pm-debug-info-on-span ) M-n M-p Print values of relevant variables in current buffer ( pm-debug-print-relevant-variables ) M-n M-t i Toggle info messages ( pm-debug-toogle-info-message ) M-n M-t f Toggle whether font-lock should be performed ( pm-debug-toggle-fontification ) M-n M-t p Toggle post-command hook ( pm-debug-toggle-post-command ) M-n M-t c Toggle after-change hook ( pm-debug-toggle-after-change ) M-n M-t a Toggle all ( pm-debug-toggle-all ) M-n M-t v Toggle verbose messages from polymode ( pm-debug-toggle-verbose ) M-n M-f s Fontify current span (useful for font-lock debugging when font-lock is off) ( pm-debug-fontify-current-span ) M-n M-f b Fontify current buffer ( pm-debug-fontify-current-buffer )","title":"For Developers"},{"location":"internals/#major-modes-guidelines","text":"In order for major modes to work well with polimodes major modes should abide the following rules: Don't assume that there is no narrowing in place. If you retrieve text-properties or access a point in a buffer, make sure it's inside the accessible region of the buffer. Pay special attention to what happens at point-max . Use syntax-ppss instead of parse-partial-sexp . If your mode uses or defines some notion of a span or chunk, follow Emacs convention for text properties and consider spans as [left closed and right open) intervals.","title":"Major Modes Guidelines"},{"location":"internals/#api","text":"All API classes and methods are named with pm- prefix. Buffer local objects: pm/polymode pm/chunkmode [!! don't rely on this one. Likely to change !!] Generics: pm-initialize pm-get-buffer-create pm-select-buffer pm-get-span pm-indent-line pm-get-adjust-face Utilities: Spans: pm-innermost-span pm-map-over-spans pm-narrow-to-span Buffers pm-set-buffer pm-switch-to-buffer Others pm-fun-matcher","title":"API"},{"location":"internals/#initialization-of-polymodes","text":"TODO","title":"Initialization of polymodes"},{"location":"internals/#poly-lock","text":"TODO","title":"Poly Lock"},{"location":"internals/#debugging-polymodes","text":"You can visually inspect if the polymode does what you intended by activating globalized pm-debug minor mode with M-x pm-debug-mode . When pm-debug-mode is active the current span will be highlighted. Some useful commands defined in pm-debug-mode-map : Shortcut Description M-n M-f Toggle font-locking ( pm-debug-toggle-fontification ) M-n M-h Map through all spans and briefly blink each span ( pm-debug-map-over-spans-and-highlight ) M-n M-i Highlight current span and display more info ( pm-debug-info-on-span ) M-n M-p Print values of relevant variables in current buffer ( pm-debug-print-relevant-variables ) M-n M-t i Toggle info messages ( pm-debug-toogle-info-message ) M-n M-t f Toggle whether font-lock should be performed ( pm-debug-toggle-fontification ) M-n M-t p Toggle post-command hook ( pm-debug-toggle-post-command ) M-n M-t c Toggle after-change hook ( pm-debug-toggle-after-change ) M-n M-t a Toggle all ( pm-debug-toggle-all ) M-n M-t v Toggle verbose messages from polymode ( pm-debug-toggle-verbose ) M-n M-f s Fontify current span (useful for font-lock debugging when font-lock is off) ( pm-debug-fontify-current-span ) M-n M-f b Fontify current buffer ( pm-debug-fontify-current-buffer )","title":"Debugging Polymodes"},{"location":"licence/","text":"Copyright (C) 2012-2016 Vitalie Spinu and contributors . Polymode is distributed under the GNU General Public License, version 3, the same as Emacs. Type C-h C-c in Emacs to view it.","title":"Licence"},{"location":"screenshots/","text":"Screenshots Slim Markdown+R Markdown+R+YAML Org mode Ess-help buffer C++R","title":"Screenshots"},{"location":"screenshots/#screenshots","text":"","title":"Screenshots"},{"location":"screenshots/#slim","text":"","title":"Slim"},{"location":"screenshots/#markdownr","text":"","title":"Markdown+R"},{"location":"screenshots/#markdownryaml","text":"","title":"Markdown+R+YAML"},{"location":"screenshots/#org-mode","text":"","title":"Org mode"},{"location":"screenshots/#ess-help-buffer","text":"","title":"Ess-help buffer"},{"location":"screenshots/#cr","text":"","title":"C++R"},{"location":"usage/","text":"All polymode keys start with the prefix defined by polymode-prefix-key (defaults to M-n ). The polymode-mode-map is the parent of all polymodes' maps. Navigation All polymode navigation commands are \"cycling commands\" in the sense that they can be invoked repeatedly with the press of the basic keys. For example, if the polymode-minor-mode-map is bound to the default M-n prefix, then the sequence M-n C-n C-n C-p will invoke polymode-next-chunk twice and polymode-previous-chunk once. Shortcut Description C-n Move to next chunk ( polymode-next-chunk ) C-p Move to previous chunk ( polymode-previous-chunk ) C-M-n Move to next chunk of the same type ( polymode-next-chunk-same-type ) C-M-p Move to previous chunk of the same type ( polymode-previous-chunk-same-type ) Chunk Manipulation Shortcut Description M-k Kill current chunk ( polymode-kill-chunk ) C-t Toggle narrowing of the body of current chunk ( polymode-toggle-chunk-narrowing ) M-m DWIM repeatedly mark or extend region ( polymode-mark-or-extend-chunk , a \"cycling\" command) Exporting, Weaving and Tangling Shortcut Description e Export the document with the current exporter. ( polymode-export ) E Ask and set the current exporter. ( polymode-set-exporter ) w Weave the document with the current weaver. ( polymode-weave ) W Ask and set the current weaver. ( polymode-set-weaver ) t ;; not implemented yet ( polymode-tangle ) T ;; not implemented yet ( polymode-set-tangler ) $ Show the process buffer is something went wrong during the processing. ( polymode-show-process-buffer ) Evaluation of Chunks Many Emacs modes provide interactive evaluation of code. The output of the evaluation is commonly directed into an inferior process buffer or directly into the source buffer (e.g. org-mode ). Polymode provides a few generic commands in polymode-eval-map ( M-n v by default) in order to facilitate evaluation of code in polymode buffers. Shortcut Description v Eval all inner chunks in a region if region is active or the current chunk at point ( polymode-eval-region-or-chunk ) b Eval all inner chunks in a buffer ( polymode-eval-buffer ) u or \u2191 Eval from beginning of buffer till point ( polymode-eval-buffer-from-beg-to-point ) d or \u2193 Eval from point till end of buffer ( polymode-eval-buffer-from-point-to-end )","title":"Basic Usage"},{"location":"usage/#navigation","text":"All polymode navigation commands are \"cycling commands\" in the sense that they can be invoked repeatedly with the press of the basic keys. For example, if the polymode-minor-mode-map is bound to the default M-n prefix, then the sequence M-n C-n C-n C-p will invoke polymode-next-chunk twice and polymode-previous-chunk once. Shortcut Description C-n Move to next chunk ( polymode-next-chunk ) C-p Move to previous chunk ( polymode-previous-chunk ) C-M-n Move to next chunk of the same type ( polymode-next-chunk-same-type ) C-M-p Move to previous chunk of the same type ( polymode-previous-chunk-same-type )","title":"Navigation"},{"location":"usage/#chunk-manipulation","text":"Shortcut Description M-k Kill current chunk ( polymode-kill-chunk ) C-t Toggle narrowing of the body of current chunk ( polymode-toggle-chunk-narrowing ) M-m DWIM repeatedly mark or extend region ( polymode-mark-or-extend-chunk , a \"cycling\" command)","title":"Chunk Manipulation"},{"location":"usage/#exporting-weaving-and-tangling","text":"Shortcut Description e Export the document with the current exporter. ( polymode-export ) E Ask and set the current exporter. ( polymode-set-exporter ) w Weave the document with the current weaver. ( polymode-weave ) W Ask and set the current weaver. ( polymode-set-weaver ) t ;; not implemented yet ( polymode-tangle ) T ;; not implemented yet ( polymode-set-tangler ) $ Show the process buffer is something went wrong during the processing. ( polymode-show-process-buffer )","title":"Exporting, Weaving and Tangling"},{"location":"usage/#evaluation-of-chunks","text":"Many Emacs modes provide interactive evaluation of code. The output of the evaluation is commonly directed into an inferior process buffer or directly into the source buffer (e.g. org-mode ). Polymode provides a few generic commands in polymode-eval-map ( M-n v by default) in order to facilitate evaluation of code in polymode buffers. Shortcut Description v Eval all inner chunks in a region if region is active or the current chunk at point ( polymode-eval-region-or-chunk ) b Eval all inner chunks in a buffer ( polymode-eval-buffer ) u or \u2191 Eval from beginning of buffer till point ( polymode-eval-buffer-from-beg-to-point ) d or \u2193 Eval from point till end of buffer ( polymode-eval-buffer-from-point-to-end )","title":"Evaluation of Chunks"}]}